<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hero LABS CTY GAME</title>
  <!-- Using a retro pixel font from Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
  <style>
  
    /* Global & Base Styles */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: #1a1a1a;
      color: #FFD700;
      font-family: 'Press Start 2P', monospace;
      image-rendering: pixelated;
      overflow: hidden;
    }
    
    /* Header */
    #header {
      text-align: center;
      font-size: 20px;
      padding: 10px;
      border-bottom: 3px solid #FFD700;
      background: #333;
      box-shadow: 4px 4px 0 #000;
      position: relative;
      z-index: 2;
    }
    
    /* Patch Timer – now the construction timer – on the upper left */
    #patchTimer {
      position: fixed;
      top: 10px;
      left: 10px;
      background: #222;
      padding: 5px 10px;
      border: 2px solid #FFD700;
      box-shadow: 2px 2px 0 #000;
      z-index: 100;
      font-size: 12px;
      pointer-events: none;
    }
    
    /* Top Bar – Agent details on the upper right */
    #topBar {
      position: fixed;
      top: 10px;
      right: 10px;
      background: #444;
      padding: 5px 10px;
      border: 2px solid #FFD700;
      box-shadow: 2px 2px 0 #000;
      font-size: 12px;
      z-index: 100;
    }
    
    /* Instruction Button (now inside sidebar) */
    .small-instruction-button {
      font-size: 14px;
      padding: 6px 10px;
      border: 1px solid #FFD700;
      background: #555;
      color: #FFD700;
      cursor: pointer;
      border-radius: 4px;
      transition: transform 0.2s ease;
      box-shadow: 2px 2px 0 #000;
    }
    .small-instruction-button:hover {
      transform: translate(2px,2px);
      background: #666;
    }
    
    /* Block Details Tooltip */
    #blockDetails {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      color: #FFD700;
      padding: 8px;
      border: 1px solid #FFD700;
      font-size: 10px;
      display: none;
      z-index: 50;
      pointer-events: none;
      border-radius: 2px;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    
    /* Main Container */
    #container { 
      display: flex; 
      margin-top: 50px;
      height: calc(100vh - 50px);
    }
    
    /* Sidebar Styling */
    #sidebar {
      width: 280px;
      background: #2c2c2c;
      border-right: 2px solid #FFD700;
      padding: 10px;
      overflow-y: auto;
      font-size: 10px;
    }
    /* Sidebar header for Resources title and info button */
    #sidebar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    #sidebar h2 {
      margin: 0;
      font-size: 12px;
      border-bottom: 2px solid #FFD700;
      padding-bottom: 5px;
    }
    .resource-list, .requirement-list {
      list-style: none;
      margin-bottom: 5px;
      padding-left: 1;
    }
    .resource-list li, .requirement-list li { 
      margin: 2px 0; 
      position: relative; 
    }
    /* Resource Icon Styles */
    .icon { 
      display: inline-block; 
      width: 15px; 
      height: 15px; 
      margin-right: 1px; 
      vertical-align: middle; 
      border: 1px solid #FFD700;
    }
    .gold-icon { background: #FFD700; }
    .silver-icon { background: #C0C0C0; }
    .diamond-icon { background: #7FFFD4; }
    .bronze-icon { background: #CD7F32; }
    .iron-icon { background: #666666; }
    .steel-icon { background: #B0C4DE; }
    .wood-icon { background: #8B4513; }
    .food-icon { background: #00FF00; }
    .utility-icon { background: #00BFFF; }
    .population-icon { background: #FF69B4; }
    .stone-icon { background: #808080; }
    .water-icon { background: #1E90FF; }
    
    /* Production Popup Animation */
    .popup {
      margin-left: 5px;
      font-size: 8px;
      opacity: 0;
      animation: popupAnimation 1s ease-out forwards;
    }
    @keyframes popupAnimation {
      0% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-10px); }
    }
    
    /* Buttons Containers */
    #inventory, #acquireAgentContainer, #mapUpgradeContainer {
      display: flex; 
      flex-wrap: wrap; 
      gap: 4px; 
      justify-content: center; 
      margin-bottom: 10px;
    }
    
    /* Resources Building Heading */
    #resourcesBuildingHeading {
      text-align: center;
      font-size: 12px;
      margin-bottom: 5px;
      border-bottom: 2px solid #FFD700;
      padding-bottom: 3px;
    }
    
    /* Buttons Style */
    .inventory-button, .map-upgrade-button, .instruction-button, .reset-button {
      flex: 1 1 45%;
      padding: 4px;
      border: 2px solid #FFD700;
      background: #555;
      color: #FFD700;
      text-align: center;
      font-size: 10px;
      cursor: pointer;
      border-radius: 2px;
      transition: transform 0.1s ease;
      box-shadow: 2px 2px 0 #000;
    }
    .inventory-button:hover, .map-upgrade-button:hover, .instruction-button:hover, .reset-button:hover {
      transform: translate(2px,2px);
      background: #666;
    }
    .inventory-button.selected { background: #FFD700; color: #222; }
    
    /* Game Area & Canvas */
    #gameArea {
      flex: 1;
      position: relative;
      background: #000;
      overflow: auto;
      padding: 10px;
    }
    canvas {
      image-rendering: pixelated;
      box-shadow: 4px 4px 0 #000;
    }
    
    /* Action Menu with Slide/Fade Animation */
#actionMenu {
  position: absolute;
  background: #444;
  border: 2px solid #FFD700;
  padding: 8px;
  font-size: 12px;
  z-index: 30;
  display: none;
  opacity: 0;
  transform: translateY(-5px) translateX(-50%);
  transition: opacity 0.2s ease, transform 0.2s ease;
  border-radius: 4px;
  box-shadow: 2px 2px 0 #000;
  width: 75px;
  min-width: 75px;
  transform-origin: left center;
}
#actionMenu.show {
  opacity: 1;
  transform: translateY(0) translateX(-50%);
}
    #actionMenu button {
      margin: 2px;
      padding: 4px 6px;
      border: 1px solid;
      background: #555;
      cursor: pointer;
      font-size: 10px;
      border-radius: 3px;
      transition: all 0.2s ease;
      box-shadow: 1px 1px 0 #000;
      width: 100%;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
      position: relative;
      overflow: hidden;
    }
    #actionMenu button::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 100%;
      height: 200%;
      background: linear-gradient(45deg, 
        transparent, 
        rgba(255,215,0,0.2) 30%, 
        transparent 70%);
      transform: rotate(45deg);
      transition: all 0.3s ease;
    }
    #actionMenu button:hover {
      transform: translate(2px,2px);
      box-shadow: 0 0 5px #FFD700;
    }
    #actionMenu button:hover::before {
      animation: borderGlow 1.5s infinite;
    }
    @keyframes borderGlow {
      0% { transform: rotate(45deg) translate(-60%, -60%); }
      100% { transform: rotate(45deg) translate(60%, 60%); }
    }
    #actionMenu button:hover {
      transform: translate(1px,1px);
      background: #666;
    }
    
    /* Instructions Modal Fade & Scale */
    #instructionsModal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.85);
      z-index: 200;
      justify-content: center;
      align-items: center;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    #instructionsModal.show { display: flex; opacity: 1; }
    #instructionsModal .modal-content {
      background: #333;
      border: 2px solid #FFD700;
      padding: 20px;
      width: 500px;
      font-size: 10px;
      color: #FFD700;
      text-align: left;
      image-rendering: pixelated;
      transform: scale(0.9);
      transition: transform 0.3s ease;
      border-radius: 4px;
      box-shadow: 4px 4px 0 #000;
    }
    #instructionsModal.show .modal-content {
      transform: scale(1);
    }
    #instructionsModal .close-button {
      background: #FFD700;
      color: #222;
      border: none;
      padding: 4px 8px;
      cursor: pointer;
      margin-top: 10px;
      font-size: 10px;
      border-radius: 2px;
      box-shadow: 2px 2px 0 #000;
    }
    
    /* NEW: Resource Tooltip CSS */
    #resourceTooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      color: #FFD700;
      padding: 4px 8px;
      border: 1px solid #FFD700;
      font-size: 10px;
      display: none;
      z-index: 200;
      pointer-events: none;
      border-radius: 2px;
      transition: opacity 0.3s ease;
    }
    
    /* NEW: Food Consumption Display */
    #foodConsumptionDisplay {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border: 2px solid #FFD700;
      font-size: 10px;
      color: #FFD700;
      z-index: 150;
      pointer-events: none;
      border-radius: 2px;
    }
    
    /* NEW: Floating Text Animation for Resource Gain/Loss */
    .floating-text {
      position: absolute;
      pointer-events: none;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      color: #FFD700;
      animation: floatUp 1.5s ease-out forwards;
      z-index: 150;
    }
    @keyframes floatUp {
      0% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-20px); }
    }
    
    /* NEW: Obstacle Action Menu */
    #obstacleActionMenu {
      position: absolute;
      background: #444;
      border: 2px solid #FFD700;
      padding: 4px;
      font-size: 10px;
      z-index: 30;
      display: none;
      border-radius: 2px;
      box-shadow: 2px 2px 0 #000;
    }
    #obstacleActionMenu button {
      margin: 2px;
      padding: 2px 4px;
      border: 1px solid #FFD700;
      background: #555;
      color: #FFD700;
      cursor: pointer;
      font-size: 10px;
      border-radius: 2px;
      transition: transform 0.1s ease;
      box-shadow: 1px 1px 0 #000;
    }
    #obstacleActionMenu button:hover {
      transform: translate(1px,1px);
      background: #666;
    }
	/* CSS for the Resources Building Image Buttons */
    .building-img {
      width: 35px;
      height: 35px;
      object-fit: cover;
      display: block;
      margin: 0 auto;
    }
    .inventory-button {
      background: none;
      border: none;
      padding: 0px;
      cursor: pointer;
    }
    .inventory-button:hover {
      transform: translateY(-2px);
      transition: transform 0.1s ease;
    }
	
  </style>
  <script>
  window.playerInventory = []; // or load saved inventory if applicable
  window.resources = {
    gold: 9999999,
    silver: 9999999,
    diamond: 9999999,
    bronze: 9999999,
    iron: 9999999,
    steel: 9999999,
    wood: 9999999,
    stone: 9999999,
    water: 9999999,
    food: 9999999,
    utility: 9999999,
    population: 55555
  };
</script>

</head>
<body>
  <!-- Header -->
  <div id="header">Hero LABS CTY GAME</div>
  
  <!-- Patch Timer (construction timer) on the upper left -->
  <div id="patchTimer">No construction</div>
  
  <!-- Top Bar (Agent details on the upper right) -->
  <div id="topBar">Hero: 2 | Synthetic: 0</div>
  
  <div id="container">
    <!-- Sidebar -->
    <div id="sidebar">
      <div id="sidebar-header">
        <h2>RESOURCES</h2>
        <button id="instructionBtn" class="small-instruction-button">Info</button>
      </div>
      <ul class="resource-list" id="resourceList">
        <li><span class="icon gold-icon"></span>Gold: <span id="res-gold">0</span> <span class="popup" id="popup-gold"></span></li>
        <li><span class="icon silver-icon"></span>Silver: <span id="res-silver">0</span> <span class="popup" id="popup-silver"></span></li>
        <li><span class="icon diamond-icon"></span>Diamond: <span id="res-diamond">0</span> <span class="popup" id="popup-diamond"></span></li>
        <li><span class="icon bronze-icon"></span>Bronze: <span id="res-bronze">0</span> <span class="popup" id="popup-bronze"></span></li>
        <li><span class="icon iron-icon"></span>Iron: <span id="res-iron">0</span> <span class="popup" id="popup-iron"></span></li>
        <li><span class="icon steel-icon"></span>Steel: <span id="res-steel">0</span> <span class="popup" id="popup-steel"></span></li>
        <li><span class="icon wood-icon"></span>Wood: <span id="res-wood">0</span> <span class="popup" id="popup-wood"></span></li>
        <li><span class="icon stone-icon"></span>Stone: <span id="res-stone">0</span> <span class="popup" id="popup-stone"></span></li>
        <li><span class="icon water-icon"></span>Water: <span id="res-water">0</span> <span class="popup" id="popup-water"></span></li>
        <li><span class="icon food-icon"></span>Food: <span id="res-food">0</span> <span class="popup" id="popup-food"></span></li>
        <li><span class="icon utility-icon"></span>Utility: <span id="res-utility">0</span> <span class="popup" id="popup-utility"></span></li>
        <li><span class="icon population-icon"></span>Population: <span id="res-population">0</span> <span class="popup" id="popup-population"></span></li>
      </ul>
      
      <!-- Resources Building -->
<div id="resourcesBuildingHeading">RESOURCES BUILDING</div>
<div id="inventory">
  <!-- Gold Mine -->
  <button class="inventory-button" data-type="gold">
    <img 
      src="https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/26fb98a4add470775b474216f8a12f7e58350a21ba572327c9b35c1b6f18a5f9.png" 
      alt="Gold Mine" 
      class="building-img">
  </button>
  
  <!-- Silver Mine -->
  <button class="inventory-button" data-type="silver">
    <img 
      src="https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/322dde56b2a7ef85a70b1e16fe2f343dac77c5b1ad7612d99c77d5d9b451b987.png" 
      alt="Silver Mine" 
      class="building-img">
  </button>
  
  <!-- Diamond Mine -->
  <button class="inventory-button" data-type="diamond">
    <img 
      src="https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/508b83819c0355b90eda8030607adbc56970fedc00ab125e3690b4dfc33c04bd.png" 
      alt="Diamond Mine" 
      class="building-img">
  </button>
  
  <!-- Bronze Mine -->
  <button class="inventory-button" data-type="bronze">
    <img 
      src="https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/8cbffe6c6a3541a0fb952be57372c0e109ff0fbbf3bff45d500a41160a7c7c47.png" 
      alt="Bronze Mine" 
      class="building-img">
  </button>
  
  <!-- Iron Mine -->
  <button class="inventory-button" data-type="iron">
    <img 
      src="https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/0b7e27c2289b05a14be3ce641b8aaf8b4ee4485f752eaeeed7224e6eb1d6a9a2.png" 
      alt="Iron Mine" 
      class="building-img">
  </button>
  
  <!-- Steel Mill -->
  <button class="inventory-button" data-type="steel">
    <img 
      src="https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/8a069381aed459def191a88261b12f57b39ca519dc9a6d963c898b52a00a68e8.png" 
      alt="Steel Mill" 
      class="building-img">
  </button>
  
  <!-- Lumber Mill -->
  <button class="inventory-button" data-type="wood">
    <img 
      src="https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/a17cbe90a9efd09d5822b21133fc8f9453ae00183691462c202e7b404b283fe8.png" 
      alt="Lumber Mill" 
      class="building-img">
  </button>
  
  <!-- Food Farm -->
  <button class="inventory-button" data-type="food">
    <img 
      src="https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/3de899a5bbeea4fbd62ca7a0cdf606624a90e7ef15e0573816a512c2f30d0d85.png" 
      alt="Food Farm" 
      class="building-img">
  </button>
  
  <!-- Utility Center -->
  <button class="inventory-button" data-type="utility">
    <img 
      src="https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/7b8d6f93dcda57204d49a3550439d3d593bb8da285e6312d038873a1bc99bebe.png" 
      alt="Utility Center" 
      class="building-img">
  </button>
  
  <!-- Housing -->
  <button class="inventory-button" data-type="housing">
    <img 
      src="https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/71f43b8833018c859355d218ff66fcaf83645b4ed2238d4482b6288966dff9c2.png" 
      alt="Housing" 
      class="building-img">
  </button>
  
  <!-- Quarry -->
  <button class="inventory-button" data-type="quarry">
    <img 
      src="https://cdn.midjourney.com/u/1de11c14-3230-4a0b-beee-2b3fd1791539/385409230e30f939713800dd894410752afd85dd6e6c4ee7943c058b928ede53.png" 
      alt="Quarry" 
      class="building-img">
  </button>
  
  <!-- Well -->
  <button class="inventory-button" data-type="well">
    <img 
      src="https://cdn.midjourney.com/u/1de11c14-3230-4a0b-beee-2b3fd1791539/1aa3a9b080eac5870d538a722d5b10f88331d07c64486c279e38d282cb5be35a.png" 
      alt="Well" 
      class="building-img">
  </button>
</div>

      
      <!-- Acquire Synthetic Agent -->
      <div id="acquireAgentContainer">
        <p style="font-size:8px; text-align:center;">Synthetic Agents: <span id="syntheticAgentsCountDisplay">0</span></p>
        <button id="acquireSyntheticAgentButton" class="instruction-button">Acquire Agent</button>
      </div>
      
      <h2>NEXT ERA REQUIREMENTS</h2>
      <ul class="requirement-list" id="requirementList">
        <li>Gold: <span id="req-gold"></span></li>
        <li>Silver: <span id="req-silver"></span></li>
        <li>Diamond: <span id="req-diamond"></span></li>
        <li>Bronze: <span id="req-bronze"></span></li>
        <li>Iron: <span id="req-iron"></span></li>
        <li>Steel: <span id="req-steel"></span></li>
        <li>Wood: <span id="req-wood"></span></li>
        <li>Stone: <span id="req-stone"></span></li>
        <li>Water: <span id="req-water"></span></li>
        <li>Food: <span id="req-food"></span></li>
        <li>Utility: <span id="req-utility"></span></li>
        <li>Population: <span id="req-population"></span></li>
      </ul>

      <h2>MAP UPGRADE</h2>
      <div id="mapUpgradeContainer">
        <button id="upgradeMapButton" class="map-upgrade-button">Upgrade Map</button>
      </div>
      
      <h2>RESET GAME</h2>
      <div id="resetContainer">
        <button id="resetGameButton" class="reset-button">Reset Game</button>
      </div>
    </div> 
    
    <!-- Main Game Area -->
    <div id="gameArea">
      <!-- NEW: Food Consumption Display Overlay -->
      <div id="foodConsumptionDisplay">Food Consumption: 0.00 per 10 sec</div>
      <canvas id="gameCanvas"></canvas>
      <!-- Tooltip for building details -->
      <div id="blockDetails"></div>
      <!-- Action Menu -->
      <div id="actionMenu">
        <button id="startButton">Start</button>
        <button id="stopButton">Stop</button>
        <button id="upgradeButton">Upgrade</button>
        <button id="toggleHeroButton">Assign Hero</button>
        <button id="toggleSyntheticButton">Assign Synthetic</button>
        <button id="demolishButton">Demolish</button>
        <!-- Well-specific toggle button will be appended here dynamically if the selected building is a well -->
      </div>
      <!-- NEW: Obstacle Action Menu -->
      <div id="obstacleActionMenu">
        <button id="clearObstacleButton">Clear Obstacle</button>
        <button id="cancelObstacleButton">Cancel</button>
      </div>
    </div>
  </div>
  
  <!-- Instructions Modal -->
  <div id="instructionsModal">
    <div class="modal-content">
      <h3>Instructions</h3>
      <p>
        - Click a buildable cell to place an asset from the Resources Building.<br>
        - Construction delay = 20 sec × (# of that asset on map + 1), max 10×.<br>
        - Multiple constructions allowed simultaneously.<br>
        - The 2 starting Housing and Food Farm are instant.<br>
        - Max assets per type: 10; Food must be ≥ 300 to build resource establishments.<br>
        - 1 Food per Population. Every 10 sec, food is consumed (or reduced by half if you enable Water for Food mode on a Well).<br>
        - Click an asset for options:<br>
        &nbsp;&nbsp;• Start – activate production<br>
        &nbsp;&nbsp;• Stop – deactivate production<br>
        &nbsp;&nbsp;• Upgrade (shows requirements)<br>
        &nbsp;&nbsp;• Assign/Remove Agents<br>
        &nbsp;&nbsp;• Demolish<br>
        - Agents (Hero & Synthetic) cap starts at 2 and increases by 1 with each Map Upgrade.<br>
        - Upgrade map when you have 100k of key resources.<br>
        - Acquire Synthetic Agents using Population (10,000 per agent).<br>
        - New Buildings: Quarry (produces Stone) and Well (produces Water).<br>
        - Population production slowed (Housing produces half as much as before).<br>
        - **New Mechanics:**<br>
        &nbsp;&nbsp;• Production for Gold, Silver, Diamond, Bronze, Iron, Steel, and Quarry is doubled when beside a Mountain.<br>
        &nbsp;&nbsp;• Production for Food and Well is doubled when beside a River.<br>
        &nbsp;&nbsp;• Production for Wood is doubled when beside a Tree.<br>
        - **Upgrade Requirements:**<br>
        &nbsp;&nbsp;• Food Farm, Well, and Quarry upgrades now require 5,000 Food per upgrade.<br>
        &nbsp;&nbsp;• Each upgrade doubles the production multiplier (applied via the existing 2ˣ formula).<br>
        &nbsp;&nbsp;• These three assets can be upgraded up to level 5.<br>
        - Game autosaves; offline progress simulated on load.<br>
        - Starting Food Farm and Housing cells never have obstacles.<br>
        - **New Visual Feedback:**<br>
        &nbsp;&nbsp;• Floating number pop-ups when resources are gained or lost appear on the corresponding building.<br>
        &nbsp;&nbsp;• A “Constructed!” message appears when a building finishes construction.<br>
        - **Obstacle Interaction:**<br>
        &nbsp;&nbsp;• Click an obstacle (Mountain, Tree, or River) to clear it. Clearing costs Food and rewards a resource (Stone, Wood, or Water).<br>
        - **Obstacle Respawn:**<br>
        &nbsp;&nbsp;• Empty cells (with no building) will randomly spawn obstacles based on a customizable interval and probability.<br>
        - **Well Mode – Water for Food:**<br>
        &nbsp;&nbsp;• When you click on a Well, you can toggle "Water for Food" mode. When enabled, food consumption is reduced by half and water is consumed (at one‑quarter of the population per cycle).
      </p>
      <button class="close-button" id="closeInstructionsButton">Close</button>
    </div>
  </div>
  
  <!-- NEW: Resource Hover Tooltip (created dynamically in script) -->
  <script>
    /**********************
     * GLOBAL VARIABLES & INITIALIZATION
     **********************/
    const BLOCK_SIZE = 48; // each cell will be 32x32 pixels
    let gridRows = 15, gridCols = 15;
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = gridCols * BLOCK_SIZE;
    canvas.height = gridRows * BLOCK_SIZE;
    
    // Obstacle Respawn Settings (customizable)
    const OBSTACLE_RESPAWN_INTERVAL = 86400000; // 1 day in ms
    const OBSTACLE_RESPAWN_PROBABILITY = 0.05; // 5% chance per empty cell per cycle
    
    // Add the background image for the map blocks.
    const backgroundImg = new Image();
    backgroundImg.src = "https://cdn.midjourney.com/u/1de11c14-3230-4a0b-beee-2b3fd1791539/bf2680ac162451c6918efbd34223d5346c3f024228cb5b789bf188a4b546c7ab.png";
    
    // Build grid array for assets.
    const grid = [];
    for (let r = 0; r < gridRows; r++) {
      grid[r] = [];
      for (let c = 0; c < gridCols; c++) {
        grid[r][c] = null;
      }
    }
    
    // Build obstacles array (reserve top-left 2x2 cells for starting assets).
    let obstacles = [];
    function generateObstacleForCell(r, c) {
      if ((r === 0 && c === 0) || (r === 0 && c === 1) ||
          (r === 1 && c === 0) || (r === 1 && c === 1)) {
        return null;
      }
      if (Math.random() < 0.15) {
        const types = ["river", "tree", "mountain"];
        const type = types[Math.floor(Math.random() * types.length)];
        return { type: type };
      }
      return null;
    }
    function generateObstacles() {
      obstacles = [];
      for (let r = 0; r < gridRows; r++) {
        obstacles[r] = [];
        for (let c = 0; c < gridCols; c++) {
          obstacles[r][c] = (grid[r][c] === null) ? generateObstacleForCell(r, c) : null;
        }
      }
    }
    generateObstacles();
    
    // New helper: Check if a cell is adjacent (including diagonals) to an obstacle of a given type.
    function isAdjacentToObstacle(row, col, obstacleType) {
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          const r = row + dr;
          const c = col + dc;
          if (r >= 0 && r < gridRows && c >= 0 && c < gridCols) {
            if (obstacles[r] && obstacles[r][c] && obstacles[r][c].type === obstacleType) {
              return true;
            }
          }
        }
      }
      return false;
    }
    
    // Global Synthetic Agents pool and maximum agent capacity
    let syntheticAgentsPool = 0;
    let maxAgentCapacity = 2;
    
    /**********************
     * OBSTACLE RESPAWN FUNCTION
     **********************/
    function respawnObstacles() {
      // Loop through every cell; if there is no building and no obstacle, spawn one with a given probability.
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          if (!grid[r][c] && !obstacles[r][c]) {
            if (Math.random() < OBSTACLE_RESPAWN_PROBABILITY) {
              const types = ["river", "tree", "mountain"];
              const chosenType = types[Math.floor(Math.random() * types.length)];
              obstacles[r][c] = { type: chosenType };
            }
          }
        }
      }
      drawGrid();
    }
    setInterval(respawnObstacles, OBSTACLE_RESPAWN_INTERVAL);
    
    // Next Era Requirements.
    const nextEraRequirements = {
      gold: 10000000,
      silver: 10000000,
      diamond: 10000000,
      bronze: 10000000,
      iron: 10000000,
      steel: 10000000,
      wood: 10000000,
      stone: 10000000,
      water: 10000000,
      food: 100000000,
      utility: 100000000,
      population: 1000000
    };
    
    /**********************
     * GAME CONFIGURATION
     **********************/
    const buildingTypes = {
      gold:    { resource: "gold",    produce: 1000, cost: { food: 1 }, interval: 5000, imgUrl: "https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/26fb98a4add470775b474216f8a12f7e58350a21ba572327c9b35c1b6f18a5f9.png" },
      silver:  { resource: "silver",  produce: 1000, cost: { food: 1 }, interval: 5000, imgUrl: "https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/322dde56b2a7ef85a70b1e16fe2f343dac77c5b1ad7612d99c77d5d9b451b987.png" },
      diamond: { resource: "diamond", produce: 1000, cost: { food: 1 }, interval: 5000, imgUrl: "https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/508b83819c0355b90eda8030607adbc56970fedc00ab125e3690b4dfc33c04bd.png" },
      bronze:  { resource: "bronze",  produce: 1000, cost: { food: 1 }, interval: 5000, imgUrl: "https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/8cbffe6c6a3541a0fb952be57372c0e109ff0fbbf3bff45d500a41160a7c7c47.png" },
      iron:    { resource: "iron",    produce: 1000, cost: { food: 1 }, interval: 5000, imgUrl: "https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/0b7e27c2289b05a14be3ce641b8aaf8b4ee4485f752eaeeed7224e6eb1d6a9a2.png" },
      steel:   { resource: "steel",   produce: 1000, cost: { food: 1 }, interval: 5000, imgUrl: "https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/8a069381aed459def191a88261b12f57b39ca519dc9a6d963c898b52a00a68e8.png" },
      wood:    { resource: "wood",    produce: 2500, cost: { food: 1 }, interval: 5000, imgUrl: "https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/a17cbe90a9efd09d5822b21133fc8f9453ae00183691462c202e7b404b283fe8.png" },
      food:    { resource: "food",    produce: 2500, cost: {},         interval: 5000, imgUrl: "https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/3de899a5bbeea4fbd62ca7a0cdf606624a90e7ef15e0573816a512c2f30d0d85.png" },
      utility: { resource: "utility", produce: 2500, cost: {},         interval: 5000, imgUrl: "https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/7b8d6f93dcda57204d49a3550439d3d593bb8da285e6312d038873a1bc99bebe.png" },
      housing: { resource: "population", produce: 100, cost: {}, interval: 20000, imgUrl: "https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/71f43b8833018c859355d218ff66fcaf83645b4ed2238d4482b6288966dff9c2.png" },
      quarry:  { resource: "stone", produce: 2500, cost: {}, interval: 5000, imgUrl: "https://cdn.midjourney.com/u/1de11c14-3230-4a0b-beee-2b3fd1791539/385409230e30f939713800dd894410752afd85dd6e6c4ee7943c058b928ede53.png" },
      well:    { resource: "water", produce: 2500, cost: {}, interval: 5000, imgUrl: "https://cdn.midjourney.com/u/1de11c14-3230-4a0b-beee-2b3fd1791539/1aa3a9b080eac5870d538a722d5b10f88331d07c64486c279e38d282cb5be35a.png" }
    };
    
    // --- UPGRADE FUNCTIONS ---
    function upgradeBuilding(building) {
      if (building.level >= 10) {
        alert("Maximum asset level reached for this asset.");
        return;
      }
      const type = building.type;
      if (type === "utility") {
        let required = 5000;
        let resourcesNeeded = ["gold", "silver", "diamond", "bronze", "iron", "steel", "wood"];
        let missing = [];
        for (let res of resourcesNeeded) {
          if (resources[res] < required) {
            missing.push(res + " (" + (required - resources[res]) + " more)");
          }
        }
        let reqMessage = "Upgrading Utility requires: " + resourcesNeeded.map(r => r.charAt(0).toUpperCase() + r.slice(1) + ": " + required).join(", ") + ".\n";
        if (missing.length > 0) {
          alert("Not enough resources to upgrade Utility:\n" + missing.join(", "));
          return;
        }
        reqMessage += "\nDo you want to upgrade Utility?";
        if (!confirm(reqMessage)) return;
        for (let res of resourcesNeeded) {
          resources[res] -= required;
          addPopup(res, -required, building.row, building.col);
        }
        building.level++;
        return;
      }
      alert("This asset cannot be upgraded via this method.");
    }
    
    function upgradeRequirement(building) {
      if (building.type === "food" || building.type === "well" || building.type === "quarry") {
        if (building.level >= 5) {
          alert("Maximum " + (building.type === "food" ? "Food Farm" : (building.type === "well" ? "Well" : "Quarry")) + " level (5) reached for this asset.");
          return;
        }
        let assetName = building.type === "food" ? "Food Farm" : (building.type === "well" ? "Well" : "Quarry");
        let confirmMsg = "Upgrade " + assetName + " from level " + building.level + " to level " + (building.level + 1) + "?\nThis upgrade requires 5,000 Food.";
        if (!confirm(confirmMsg)) return;
        if (resources.food < 5000) {
          alert("Not enough Food to upgrade.");
          return;
        }
        resources.food -= 5000;
        addPopup("food", -5000, building.row, building.col);
        building.level++;
        return;
      }
      if (building.level >= 10) {
        alert("Maximum level (10) reached for this asset.");
        return;
      }
      let confirmMsg = "";
      if (["gold", "silver", "diamond", "bronze", "iron", "steel", "wood"].includes(building.type) && building.level === 1) {
        confirmMsg = "Upgrading this " + building.type + " asset to level 2 will cause it to require 2 Utility per sec to run.\n";
      }
      if (building.type === "iron") {
        confirmMsg += "This upgrade requires 10,000 Steel. Do you want to upgrade?";
        if (!confirm(confirmMsg)) return;
        if (resources.steel >= 10000) {
          resources.steel -= 10000;
          addPopup("steel", -10000, building.row, building.col);
          building.level++;
        } else {
          alert("Not enough Steel to upgrade Iron Mine.");
        }
      } else if (building.type === "bronze") {
        confirmMsg += "This upgrade requires 10,000 Iron. Do you want to upgrade?";
        if (!confirm(confirmMsg)) return;
        if (resources.iron >= 10000) {
          resources.iron -= 10000;
          addPopup("iron", -10000, building.row, building.col);
          building.level++;
        } else {
          alert("Not enough Iron to upgrade Bronze Mine.");
        }
      } else if (building.type === "diamond") {
        confirmMsg += "This upgrade requires 10,000 Gold and 10,000 Silver. Do you want to upgrade?";
        if (!confirm(confirmMsg)) return;
        if (resources.gold >= 10000 && resources.silver >= 10000) {
          resources.gold -= 10000;
          resources.silver -= 10000;
          addPopup("gold", -10000, building.row, building.col);
          addPopup("silver", -10000, building.row, building.col);
          building.level++;
        } else {
          alert("Not enough Gold and Silver to upgrade Diamond Mine.");
        }
      } else if (building.type === "silver") {
        confirmMsg += "This upgrade requires 10,000 Bronze. Do you want to upgrade?";
        if (!confirm(confirmMsg)) return;
        if (resources.bronze >= 10000) {
          resources.bronze -= 10000;
          addPopup("bronze", -10000, building.row, building.col);
          building.level++;
        } else {
          alert("Not enough Bronze to upgrade Silver Mine.");
        }
      } else if (building.type === "gold") {
        confirmMsg += "This upgrade requires 10,000 Silver. Do you want to upgrade?";
        if (!confirm(confirmMsg)) return;
        if (resources.silver >= 10000) {
          resources.silver -= 10000;
          addPopup("silver", -10000, building.row, building.col);
          building.level++;
        } else {
          alert("Not enough Silver to upgrade Gold Mine.");
        }
      } else if (building.type === "steel") {
        confirmMsg += "This upgrade requires 10,000 Iron. Do you want to upgrade?";
        if (!confirm(confirmMsg)) return;
        if (resources.iron >= 10000) {
          resources.iron -= 10000;
          addPopup("iron", -10000, building.row, building.col);
          building.level++;
        } else {
          alert("Not enough Iron to upgrade Steel Mill.");
        }
      } else if (building.type === "wood") {
        confirmMsg += "This upgrade requires 10,000 Food. Do you want to upgrade?";
        if (!confirm(confirmMsg)) return;
        if (resources.food >= 10000) {
          resources.food -= 10000;
          addPopup("food", -10000, building.row, building.col);
          building.level++;
        } else {
          alert("Not enough Food to upgrade Lumber Mill.");
        }
      } else {
        upgradeBuilding(building);
      }
    }
    
    const typeAbbrev = {
      gold: "G",
      silver: "S",
      diamond: "D",
      bronze: "B",
      iron: "I",
      steel: "St",
      wood: "W",
      food: "F",
      utility: "U",
      housing: "H",
      quarry: "Q",
      well: "We"
    };
    
    // Pre-load images.
    const resourceImages = {};
    for (let type in buildingTypes) {
      if (buildingTypes[type].imgUrl && buildingTypes[type].imgUrl.trim() !== "") {
        let img = new Image();
        img.src = buildingTypes[type].imgUrl;
        resourceImages[type] = img;
      }
    }
    
    // Customizable Obstacle Images.
    const customObstacleImages = {
      river: "https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/d1c284a748a373301d959361c7002f309a1a122166b8b1646b57e067f7d367e2.png",
      tree: "https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/79f459472f0c3ce6e67ab4573bbdc4d636cd5721916615ecc600566d80b14647.png",
      mountain: "https://cdn.midjourney.com/u/8ebc0538-dcef-4a1b-bdb5-cfb12ec22418/3675e23914b8a63e1eaffd24180784d5aeaac9eedfe60dfdde00733c47c4b13a.png"
    };
    const obstacleImages = {};
    if(customObstacleImages.river && customObstacleImages.river.trim() !== "") {
      let img = new Image();
      img.src = customObstacleImages.river;
      obstacleImages.river = img;
    }
    if(customObstacleImages.tree && customObstacleImages.tree.trim() !== "") {
      let img = new Image();
      img.src = customObstacleImages.tree;
      obstacleImages.tree = img;
    }
    if(customObstacleImages.mountain && customObstacleImages.mountain.trim() !== "") {
      let img = new Image();
      img.src = customObstacleImages.mountain;
      obstacleImages.mountain = img;
    }
    
    let selectedType = null;
    let currentBuilding = null;
    
    /**********************
     * PERSISTENCE FUNCTIONS
     **********************/
    function saveGame() {
      const state = {
        gridRows,
        gridCols,
        grid,
        obstacles,
        resources,
        syntheticAgentsPool,
        maxAgentCapacity,
        lastUpdate: Date.now()
      };
      localStorage.setItem("HeroLabsState", JSON.stringify(state));
    }
    
    function loadGame() {
      const saved = localStorage.getItem("HeroLabsState");
      if (saved) {
        const state = JSON.parse(saved);
        gridRows = state.gridRows;
        gridCols = state.gridCols;
        resources = state.resources;
        syntheticAgentsPool = state.syntheticAgentsPool;
        maxAgentCapacity = state.maxAgentCapacity || 2;
        grid.length = 0;
        for (let r = 0; r < gridRows; r++) {
          grid[r] = state.grid[r] || new Array(gridCols).fill(null);
        }
        obstacles = state.obstacles || [];
        canvas.width = gridCols * BLOCK_SIZE;
        canvas.height = gridRows * BLOCK_SIZE;
        if (state.lastUpdate) {
          const offlineMs = Date.now() - state.lastUpdate;
          for (let r = 0; r < gridRows; r++) {
            for (let c = 0; c < gridCols; c++) {
              const building = grid[r][c];
              if (building && !building.underConstruction && building.active) {
                const interval = buildingTypes[building.type].interval;
                let cycles = Math.floor(offlineMs / interval);
                if (cycles > 0) {
                  let production = buildingTypes[building.type].produce * Math.pow(2, building.level - 1);
                  const resourceAssets = ["gold", "silver", "diamond", "bronze", "iron", "steel", "wood"];
                  if (resourceAssets.includes(building.type)) {
                    let multiplier = 1;
                    if (building.HeroAgentAssigned) multiplier *= 10;
                    if (building.syntheticAgentAssigned) multiplier *= 2;
                    production *= multiplier;
                    let totalProduction = production * cycles;
                    let foodCost = ((buildingTypes[building.type].cost.food || 0) * building.level) * cycles;
                    if (resources.food >= foodCost) {
                      resources[buildingTypes[building.type].resource] += totalProduction;
                      resources.food -= foodCost;
                    } else {
                      let possibleCycles = Math.floor(resources.food / (((buildingTypes[building.type].cost.food || 0) * building.level) || 1));
                      resources[buildingTypes[building.type].resource] += production * possibleCycles;
                      resources.food = 0;
                    }
                  } else if (["food", "utility", "quarry", "well"].includes(building.type)) {
                    resources[buildingTypes[building.type].resource] += production * cycles;
                  } else if (building.type === "housing") {
                    resources[buildingTypes[building.type].resource] += production * cycles;
                  }
                }
              }
            }
          }
        }
      }
    }
    
    if (localStorage.getItem("HeroLabsState")) {
      loadGame();
    } else {
      const now = Date.now();
      grid[0][0] = { type: "housing", row: 0, col: 0, active: true, level: 1, underConstruction: false, constructionComplete: 0, nextProduction: now + buildingTypes["housing"].interval, HeroAgentAssigned: false, syntheticAgentAssigned: false };
      grid[0][1] = { type: "housing", row: 0, col: 1, active: true, level: 1, underConstruction: false, constructionComplete: 0, nextProduction: now + buildingTypes["housing"].interval, HeroAgentAssigned: false, syntheticAgentAssigned: false };
      grid[1][0] = { type: "food", row: 1, col: 0, active: true, level: 1, underConstruction: false, constructionComplete: 0, nextProduction: now + buildingTypes["food"].interval, HeroAgentAssigned: false, syntheticAgentAssigned: false };
      grid[1][1] = { type: "food", row: 1, col: 1, active: true, level: 1, underConstruction: false, constructionComplete: 0, nextProduction: now + buildingTypes["food"].interval, HeroAgentAssigned: false, syntheticAgentAssigned: false };
    }
    
    /**********************
     * AGENT HELPER FUNCTIONS
     **********************/
    function getTotalAssignedAgents() {
      let count = 0;
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          const building = grid[r][c];
          if (building) {
            if (building.HeroAgentAssigned) count++;
            if (building.syntheticAgentAssigned) count++;
          }
        }
      }
      return count;
    }
    
    function getTotalSyntheticAgents() {
      let count = syntheticAgentsPool;
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          const building = grid[r][c];
          if (building && building.syntheticAgentAssigned) count++;
        }
      }
      return count;
    }
    
    /**********************
     * MAP UPGRADE FUNCTION
     **********************/
    function upgradeMap() {
      const required = 100000;
      const resourcesNeeded = ["gold", "silver", "diamond", "bronze", "iron", "steel", "wood"];
      for (let res of resourcesNeeded) {
        if (resources[res] < required) {
          alert("Not enough " + res + " to upgrade the map!");
          return;
        }
      }
      for (let res of resourcesNeeded) {
        resources[res] -= required;
        addPopup(res, -required);
      }
      const oldRows = gridRows, oldCols = gridCols;
      gridRows += 5;
      gridCols += 5;
      for (let r = 0; r < grid.length; r++) {
        while (grid[r].length < gridCols) { grid[r].push(null); }
      }
      for (let r = oldRows; r < gridRows; r++) {
        let newRow = [];
        for (let c = 0; c < gridCols; c++) { newRow.push(null); }
        grid.push(newRow);
      }
      for (let r = 0; r < gridRows; r++) {
        if (!obstacles[r]) obstacles[r] = [];
        for (let c = obstacles[r].length; c < gridCols; c++) {
          obstacles[r][c] = generateObstacleForCell(r, c);
        }
      }
      canvas.width = gridCols * BLOCK_SIZE;
      canvas.height = gridRows * BLOCK_SIZE;
      drawGrid();
      updateResourceDisplay();
      maxAgentCapacity++;
      alert("Map Upgraded! Agent capacity increased to " + maxAgentCapacity);
    }
    
    /**********************
     * SYNTHETIC AGENT ACQUISITION
     **********************/
    function SyntheticAgents() {
      if (getTotalSyntheticAgents() >= maxAgentCapacity) {
        alert("Maximum Synthetic Agents (" + maxAgentCapacity + ") reached.");
        return;
      }
      if (resources.population >= 10000) {
        resources.population -= 10000;
        addPopup("population", -10000);
        syntheticAgentsPool++;
        alert("Synthetic Agent acquired!");
        updateResourceDisplay();
      } else {
        alert("Not enough Population for a Synthetic Agent (need 10,000).");
      }
    }
    
    /**********************
     * UPDATE AGENT DETAILS
     **********************/
    function updateAgentDetails() {
      let Hero = [];
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          const building = grid[r][c];
          if (building && building.HeroAgentAssigned) {
            Hero.push(building.type + "(" + r + "," + c + ")");
          }
        }
      }
      let HeroText = Hero.length ? Hero.join(" | ") : "None";
      document.getElementById("topBar").innerText = "Hero: " + HeroText + " | Synthetic: " + syntheticAgentsPool;
    }
    
    /**********************
     * DRAW FUNCTIONS
     **********************/
    function updateResourceDisplay() {
      document.getElementById("res-gold").innerText = resources.gold;
      document.getElementById("res-silver").innerText = resources.silver;
      document.getElementById("res-diamond").innerText = resources.diamond;
      document.getElementById("res-bronze").innerText = resources.bronze;
      document.getElementById("res-iron").innerText = resources.iron;
      document.getElementById("res-steel").innerText = resources.steel;
      document.getElementById("res-wood").innerText = resources.wood;
      document.getElementById("res-stone").innerText = resources.stone;
      document.getElementById("res-water").innerText = resources.water;
      document.getElementById("res-food").innerText = resources.food;
      document.getElementById("res-utility").innerText = resources.utility;
      document.getElementById("res-population").innerText = resources.population;
      document.getElementById("syntheticAgentsCountDisplay").innerText = syntheticAgentsPool;
      updateEraRequirements();
      updateAgentDetails();
    }
    
    function updateEraRequirements() {
      for (let key in nextEraRequirements) {
        const required = nextEraRequirements[key];
        const current = resources[key] || 0;
        const missing = Math.max(required - current, 0);
        document.getElementById("req-" + key).innerText = missing;
      }
    }
    
    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          const x = c * BLOCK_SIZE;
          const y = r * BLOCK_SIZE;
          ctx.drawImage(backgroundImg, x, y, BLOCK_SIZE, BLOCK_SIZE);
          ctx.strokeStyle = "#FFD700";
          ctx.strokeRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
          if (obstacles[r] && obstacles[r][c]) {
            const obs = obstacles[r][c];
            if (obstacleImages[obs.type]) {
              ctx.drawImage(obstacleImages[obs.type], x, y, BLOCK_SIZE, BLOCK_SIZE);
            } else {
              if (obs.type === "river") {
                ctx.fillStyle = "#0B3D91";
                ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
                ctx.fillStyle = "#FFF";
                ctx.font = "8px monospace";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("RIV", x + BLOCK_SIZE/2, y + BLOCK_SIZE/2);
              } else if (obs.type === "tree") {
                ctx.fillStyle = "#3D2B1F";
                ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
                ctx.fillStyle = "#FFF";
                ctx.font = "8px monospace";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("TRE", x + BLOCK_SIZE/2, y + BLOCK_SIZE/2);
              } else if (obs.type === "mountain") {
                ctx.fillStyle = "#555555";
                ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
                ctx.fillStyle = "#FFF";
                ctx.font = "8px monospace";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("MTN", x + BLOCK_SIZE/2, y + BLOCK_SIZE/2);
              }
            }
          }
          const building = grid[r][c];
          if (building) {
            if (building.underConstruction) {
              ctx.fillStyle = "#333";
              ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
              ctx.fillStyle = "#FFD700";
              ctx.font = "bold 8px monospace";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText("CON", x + BLOCK_SIZE/2, y + BLOCK_SIZE/2);
            } else {
              ctx.fillStyle = building.active ? "#555" : "#933";
              ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
              if (resourceImages[building.type]) {
                const img = resourceImages[building.type];
                const imgSize = BLOCK_SIZE * 0.8;
                ctx.drawImage(img, x + (BLOCK_SIZE - imgSize)/2, y + (BLOCK_SIZE - imgSize)/2, imgSize, imgSize);
              } else {
                ctx.fillStyle = "#FFD700";
                ctx.font = "bold 10px monospace";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                const abbrev = typeAbbrev[building.type] || building.type;
                ctx.fillText(abbrev + " L" + building.level, x + BLOCK_SIZE/2, y + BLOCK_SIZE/2);
              }
              let agents = [];
              if (building.HeroAgentAssigned) agents.push("CA");
              if (building.syntheticAgentAssigned) agents.push("SA");
              if (agents.length > 0) {
                ctx.fillStyle = "#FF0000";
                ctx.font = "bold 8px monospace";
                ctx.textAlign = "left";
                ctx.textBaseline = "top";
                ctx.fillText(agents.join("+"), x + 2, y + 2);
              }
            }
          }
        }
      }
    }
    
    /**********************
     * PRODUCTION POPUPS & FLOATING TEXT
     **********************/
    function addPopup(resource, amount, row, col) {
      const popupElem = document.getElementById("popup-" + resource);
      popupElem.textContent = (amount > 0 ? "(+" + amount + ")" : "(" + amount + ")");
      popupElem.style.color = amount >= 0 ? "green" : "red";
      popupElem.style.opacity = 1;
      setTimeout(() => { popupElem.style.opacity = 0; }, 1000);
      
      let x, y;
      if (typeof row !== 'undefined' && typeof col !== 'undefined') {
        x = col * BLOCK_SIZE + BLOCK_SIZE / 2;
        y = row * BLOCK_SIZE + BLOCK_SIZE / 2;
      } else {
        const canvasRect = canvas.getBoundingClientRect();
        x = canvasRect.left + 10;
        y = canvasRect.top + 10;
      }
      spawnFloatingText(x, y, (amount > 0 ? "+" + amount : amount), amount >= 0 ? "green" : "red");
    }
    
    function spawnFloatingText(x, y, text, color) {
      const floatingText = document.createElement("div");
      floatingText.className = "floating-text";
      floatingText.style.left = x + "px";
      floatingText.style.top = y + "px";
      floatingText.style.color = color || "#FFD700";
      floatingText.textContent = text;
      document.getElementById("gameArea").appendChild(floatingText);
      setTimeout(() => { floatingText.remove(); }, 1500);
    }
    
    /**********************
     * OBSTACLE INTERACTION
     **********************/
    let currentObstacle = { row: null, col: null };
    function showObstacleMenu(screenX, screenY, row, col) {
      currentObstacle = { row, col };
      const obsType = obstacles[row][col].type;
      const clearBtn = document.getElementById("clearObstacleButton");
      if (obsType === "tree") {
        clearBtn.textContent = "Chop Tree";
      } else if (obsType === "mountain") {
        clearBtn.textContent = "Mine Mountain";
      } else if (obsType === "river") {
        clearBtn.textContent = "Damn River";
      } else {
        clearBtn.textContent = "Clear Obstacle";
      }
      const menu = document.getElementById("obstacleActionMenu");
      menu.style.left = screenX + "px";
      menu.style.top = screenY + "px";
      menu.style.display = "block";
    }
    
    function hideObstacleMenu() {
      document.getElementById("obstacleActionMenu").style.display = "none";
      currentObstacle = { row: null, col: null };
    }
    
    function clearObstacle() {
      const { row, col } = currentObstacle;
      if (row === null || col === null || !obstacles[row][col]) return;
      const obsType = obstacles[row][col].type;
      let costFood = 50;
      let reward = 0;
      let rewardResource = "";
      
      if (resources.food < costFood) {
        alert("Not enough Food to clear this obstacle!");
        return;
      }
      
      if (obsType === "tree") {
        reward = 1000;
        rewardResource = "wood";
      } else if (obsType === "mountain") {
        reward = 1000;
        rewardResource = "stone";
      } else if (obsType === "river") {
        reward = 1000;
        rewardResource = "water";
      }
      
      resources.food -= costFood;
      resources[rewardResource] += reward;
      
      const x = col * BLOCK_SIZE + 5;
      const y = row * BLOCK_SIZE + 5;
      spawnFloatingText(x, y, `-${costFood} Food`, "red");
      spawnFloatingText(x, y - 15, `+${reward} ${rewardResource.charAt(0).toUpperCase() + rewardResource.slice(1)}`, "green");
      
      obstacles[row][col] = null;
      
      updateResourceDisplay();
      drawGrid();
      hideObstacleMenu();
    }
    
    document.getElementById("clearObstacleButton").addEventListener("click", clearObstacle);
    document.getElementById("cancelObstacleButton").addEventListener("click", hideObstacleMenu);
    
    /**********************
     * ACTION MENU
     **********************/
    const actionMenu = document.getElementById("actionMenu");
    const startButton = document.getElementById("startButton");
    const stopButton = document.getElementById("stopButton");
    const upgradeButton = document.getElementById("upgradeButton");
    const toggleHeroButton = document.getElementById("toggleHeroButton");
    const toggleSyntheticButton = document.getElementById("toggleSyntheticButton");
    const demolishButton = document.getElementById("demolishButton");
    let toggleWaterForFoodButton = null; // Will be created dynamically for wells
    
    function showActionMenu(x, y, building) {
      currentBuilding = building;
      actionMenu.style.left = x + "px";
      actionMenu.style.top = y + "px";
      actionMenu.style.display = "block";
      setTimeout(() => { actionMenu.classList.add("show"); }, 10);
      
      // If the selected building is a well, add/reuse the water mode toggle button
      if (building.type === "well") {
        // Remove existing button if it exists
        const existingBtn = document.getElementById("toggleWaterForFoodButton");
        if (existingBtn) existingBtn.remove();
        
        // Create or update the toggle button
        toggleWaterForFoodButton = document.createElement("button");
        toggleWaterForFoodButton.id = "toggleWaterForFoodButton";
        toggleWaterForFoodButton.style.margin = "2px";
        toggleWaterForFoodButton.style.padding = "2px 4px";
        toggleWaterForFoodButton.style.border = "1px solid #FFD700";
        toggleWaterForFoodButton.style.background = "#555";
        toggleWaterForFoodButton.style.color = "#FFD700";
        toggleWaterForFoodButton.style.cursor = "pointer";
        toggleWaterForFoodButton.style.fontSize = "10px";
        toggleWaterForFoodButton.style.borderRadius = "2px";
        toggleWaterForFoodButton.style.boxShadow = "1px 1px 0 #000";
        toggleWaterForFoodButton.textContent = building.waterForFood ? "Disable Water for Food" : "Enable Water for Food";
        
        // Single event handler that uses current building reference
        toggleWaterForFoodButton.addEventListener("click", (e) => {
          e.stopPropagation();
          currentBuilding.waterForFood = !currentBuilding.waterForFood;
          toggleWaterForFoodButton.textContent = currentBuilding.waterForFood ? "Disable Water for Food" : "Enable Water for Food";
          drawGrid();
          updateResourceDisplay();
        });
        
        actionMenu.appendChild(toggleWaterForFoodButton);
      }
    }
    
    function hideActionMenu() {
      actionMenu.classList.remove("show");
      setTimeout(() => { 
        actionMenu.style.display = "none"; 
        currentBuilding = null; 
        if (toggleWaterForFoodButton) {
          toggleWaterForFoodButton.remove();
          toggleWaterForFoodButton = null;
        }
      }, 200);
    }
    
    startButton.addEventListener("click", () => {
      if (currentBuilding) {
        currentBuilding.active = true;
        hideActionMenu();
        drawGrid();
      }
    });
    
    stopButton.addEventListener("click", () => {
      if (currentBuilding) {
        currentBuilding.active = false;
        hideActionMenu();
        drawGrid();
      }
    });
    
    upgradeButton.addEventListener("click", () => {
      if (currentBuilding) {
        if (["gold", "silver", "diamond", "bronze", "iron", "steel", "wood", "food", "well", "quarry"].includes(currentBuilding.type)) {
          upgradeRequirement(currentBuilding);
        } else {
          upgradeBuilding(currentBuilding);
        }
        hideActionMenu();
        drawGrid();
      }
    });
    
    toggleHeroButton.addEventListener("click", () => {
      if (currentBuilding) {
        if (!currentBuilding.HeroAgentAssigned) {
          if (getTotalAssignedAgents() < maxAgentCapacity) {
            currentBuilding.HeroAgentAssigned = true;
            if (currentBuilding.underConstruction) {
              currentBuilding.underConstruction = false;
              currentBuilding.active = true;
              currentBuilding.nextProduction = Date.now() + buildingTypes[currentBuilding.type].interval;
            }
          } else {
            alert("Maximum agent assignments reached (" + maxAgentCapacity + ").");
          }
        } else {
          currentBuilding.HeroAgentAssigned = false;
        }
        hideActionMenu();
        drawGrid();
        updateResourceDisplay();
      }
    });
    
    toggleSyntheticButton.addEventListener("click", () => {
      if (currentBuilding) {
        if (!currentBuilding.syntheticAgentAssigned) {
          if (getTotalAssignedAgents() < maxAgentCapacity) {
            if (syntheticAgentsPool > 0) {
              currentBuilding.syntheticAgentAssigned = true;
              syntheticAgentsPool--;
              if (currentBuilding.underConstruction) {
                currentBuilding.underConstruction = false;
                currentBuilding.active = true;
                currentBuilding.nextProduction = Date.now() + buildingTypes[currentBuilding.type].interval;
              }
            } else {
              alert("No Synthetic Agent available!");
            }
          } else {
            alert("Maximum agent assignments reached (" + maxAgentCapacity + ").");
          }
        } else {
          currentBuilding.syntheticAgentAssigned = false;
          syntheticAgentsPool++;
        }
        hideActionMenu();
        drawGrid();
        updateResourceDisplay();
      }
    });
    
    demolishButton.addEventListener("click", () => {
      if (currentBuilding) {
        grid[currentBuilding.row][currentBuilding.col] = null;
        hideActionMenu();
        drawGrid();
      }
    });
    
    document.addEventListener("click", (e) => {
      if (!actionMenu.contains(e.target) && e.target.id !== "gameCanvas") {
        hideActionMenu();
      }
    });
    
    /**********************
     * USER INTERACTIONS
     **********************/
    function canPlaceAsset(type) {
      const resourceAssets = ["gold", "silver", "diamond", "bronze", "iron"];
      if (resourceAssets.includes(type) && resources.food < 300) {
        alert("At least 300 Food required to build a resource establishment.");
        return false;
      }
      return true;
    }
    
    const invButtons = document.querySelectorAll(".inventory-button");
    invButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        invButtons.forEach(b => b.classList.remove("selected"));
        if (selectedType === btn.dataset.type) {
          selectedType = null;
        } else {
          selectedType = btn.dataset.type;
          btn.classList.add("selected");
        }
      });
    });
    
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const col = Math.floor(x / BLOCK_SIZE);
      const row = Math.floor(y / BLOCK_SIZE);
      
      if (obstacles[row] && obstacles[row][col]) {
        showObstacleMenu(e.clientX, e.clientY, row, col);
        return;
      }
      
      if (grid[row][col] !== null) {
        showActionMenu(x, y, grid[row][col]);
      } else if (selectedType) {
        let count = 0;
        for (let r = 0; r < gridRows; r++) {
          for (let c = 0; c < gridCols; c++) {
            if (grid[r][c] && grid[r][c].type === selectedType) count++;
          }
        }
        if (count >= 10) {
          alert("Max " + selectedType + " assets (10) reached!");
          return;
        }
        if (!canPlaceAsset(selectedType)) return;
        
        if (selectedType === "gold") {
          if (resources.silver < 10000) {
            alert("Not enough Silver to build Gold Mine!");
            return;
          }
          resources.silver -= 10000;
          addPopup("silver", -10000, row, col);
        } else if (selectedType === "diamond") {
          if (resources.gold < 10000 || resources.silver < 10000) {
            alert("Not enough Gold and Silver to build Diamond Mine!");
            return;
          }
          resources.gold -= 10000;
          resources.silver -= 10000;
          addPopup("gold", -10000, row, col);
          addPopup("silver", -10000, row, col);
        } else if (selectedType === "silver") {
          if (resources.bronze < 10000) {
            alert("Not enough Bronze to build Silver Mine!");
            return;
          }
          resources.bronze -= 10000;
          addPopup("bronze", -10000, row, col);
        } else if (selectedType === "iron") {
          if (resources.steel < 10000) {
            alert("Not enough Steel to build Iron Mine!");
            return;
          }
          resources.steel -= 10000;
          addPopup("steel", -10000, row, col);
        } else if (selectedType === "steel") {
          if (resources.wood < 10000) {
            alert("Not enough Wood to build Steel Mine!");
            return;
          }
          resources.wood -= 10000;
          addPopup("wood", -10000, row, col);
        }
        
        let multiplier = Math.min(count + 1, 10);
        let delay = 20000 * multiplier;
        if (!confirm("This " + selectedType + " will take " + (delay/1000) + " sec to construct. Proceed?")) return;
        const now = Date.now();
        grid[row][col] = {
          type: selectedType,
          row: row,
          col: col,
          active: false,
          level: 1,
          underConstruction: true,
          constructionComplete: now + delay,
          nextProduction: 0,
          HeroAgentAssigned: false,
          syntheticAgentAssigned: false
        };
        drawGrid();
      }
    });
    
    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const col = Math.floor(x / BLOCK_SIZE);
      const row = Math.floor(y / BLOCK_SIZE);
      if (row < 0 || row >= gridRows || col < 0 || col >= gridCols) {
         hideBlockDetails();
         return;
      }
      const building = grid[row][col];
      if (building) {
         updateBlockDetails(e);
      } else {
         hideBlockDetails();
      }
    });
    canvas.addEventListener("mouseleave", hideBlockDetails);
    
    function updateBlockDetails(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const col = Math.floor(x / BLOCK_SIZE);
      const row = Math.floor(y / BLOCK_SIZE);
      if (row < 0 || row >= gridRows || col < 0 || col >= gridCols) {
         hideBlockDetails();
         return;
      }
      const building = grid[row][col];
      if (!building) {
         hideBlockDetails();
         return;
      }
      let detailsHTML = "<strong>Type:</strong> " + building.type.charAt(0).toUpperCase() + building.type.slice(1) + "<br>";
      detailsHTML += "<strong>Level:</strong> " + building.level + "<br>";
      if (building.underConstruction) {
         const timeLeft = Math.ceil((building.constructionComplete - Date.now()) / 1000);
         detailsHTML += "<em>Under Construction</em><br>";
         detailsHTML += "<strong>Time Left:</strong> " + timeLeft + " sec<br>";
      } else {
         const bt = buildingTypes[building.type];
         let baseProd = bt.produce * Math.pow(2, building.level - 1);
         let multiplier = 1;
         let agentDetails = "";
         if (building.HeroAgentAssigned) {
             multiplier *= 10;
             agentDetails += "<strong>Hero:</strong> Yes<br>";
         } else {
             agentDetails += "<strong>Hero:</strong> No<br>";
         }
         if (building.syntheticAgentAssigned) {
             multiplier *= 2;
             agentDetails += "<strong>Synthetic:</strong> Yes<br>";
         } else {
             agentDetails += "<strong>Synthetic:</strong> No<br>";
         }
         let obstacleMultiplier = 1;
         if (["gold", "silver", "diamond", "bronze", "iron", "steel"].includes(building.type)) {
           if (isAdjacentToObstacle(building.row, building.col, "mountain")) {
             obstacleMultiplier *= 2;
           }
         } else if (building.type === "wood") {
           if (isAdjacentToObstacle(building.row, building.col, "tree")) {
             obstacleMultiplier *= 2;
           }
         } else if (["food", "well"].includes(building.type)) {
           if (isAdjacentToObstacle(building.row, building.col, "river")) {
             obstacleMultiplier *= 2;
           }
         } else if (building.type === "quarry") {
           if (isAdjacentToObstacle(building.row, building.col, "mountain")) {
             obstacleMultiplier *= 2;
           }
         }
         multiplier *= obstacleMultiplier;
         let effectiveProd = baseProd * multiplier;
         let prodPerSec = effectiveProd * (1000 / bt.interval);
         detailsHTML += agentDetails;
         detailsHTML += "<strong>Multiplier:</strong> x" + multiplier + "<br>";
         detailsHTML += "<strong>Prod:</strong> " + prodPerSec.toFixed(2) + " " + bt.resource + "/sec<br>";
         const resourceAssets = ["gold", "silver", "diamond", "bronze", "iron", "steel", "wood"];
         if (resourceAssets.includes(building.type) && building.level >= 2) {
           detailsHTML += "<strong>Req Utility:</strong> 2/sec<br>";
         }
      }
      const tooltip = document.getElementById("blockDetails");
      tooltip.innerHTML = detailsHTML;
      tooltip.style.display = "block";
      tooltip.style.left = (e.clientX + 10) + "px";
      tooltip.style.top = (e.clientY + 10) + "px";
    }
    
    function hideBlockDetails() {
      const tooltip = document.getElementById("blockDetails");
      tooltip.style.display = "none";
    }
    
    document.getElementById("upgradeMapButton").addEventListener("click", upgradeMap);
    
    document.getElementById("acquireSyntheticAgentButton").addEventListener("click", SyntheticAgents);
    
    document.getElementById("resetGameButton").addEventListener("click", () => {
      if (confirm("Reset game? All progress will be lost.")) {
        localStorage.removeItem("HeroLabsState");
        location.reload();
      }
    });
    
    document.getElementById("instructionBtn").addEventListener("click", () => {
      const modal = document.getElementById("instructionsModal");
      modal.style.display = "flex";
      setTimeout(() => { modal.classList.add("show"); }, 10);
    });
    document.getElementById("closeInstructionsButton").addEventListener("click", () => {
      const modal = document.getElementById("instructionsModal");
      modal.classList.remove("show");
      setTimeout(() => { modal.style.display = "none"; }, 300);
    });
    
    /**********************
     * RESOURCE HOVER TOOLTIP SETUP
     **********************/
    const resourceTooltip = document.createElement("div");
    resourceTooltip.id = "resourceTooltip";
    document.body.appendChild(resourceTooltip);
    
    function getResourceProductionPerSecond(resourceKey) {
      let total = 0;
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          const building = grid[r][c];
          if (!building || building.underConstruction || !building.active) continue;
          const bt = buildingTypes[building.type];
          if (!bt) continue;
          if (bt.resource === resourceKey) {
            let baseProd = bt.produce * Math.pow(2, building.level - 1);
            let multiplier = 1;
            if (["gold", "silver", "diamond", "bronze", "iron", "steel"].includes(building.type)) {
              if (isAdjacentToObstacle(building.row, building.col, "mountain")) {
                multiplier *= 2;
              }
            } else if (building.type === "wood") {
              if (isAdjacentToObstacle(building.row, building.col, "tree")) {
                multiplier *= 2;
              }
            } else if (building.type === "food" || building.type === "well") {
              if (isAdjacentToObstacle(building.row, building.col, "river")) {
                multiplier *= 2;
              }
            } else if (building.type === "quarry") {
              if (isAdjacentToObstacle(building.row, building.col, "mountain")) {
                multiplier *= 2;
              }
            }
            if (building.HeroAgentAssigned) multiplier *= 10;
            if (building.syntheticAgentAssigned) multiplier *= 2;
            let effectiveProduction = baseProd * multiplier;
            let prodPerSec = effectiveProduction * (1000 / bt.interval);
            total += prodPerSec;
          }
        }
      }
      return total;
    }
    
    const resourceItems = document.querySelectorAll("#resourceList li");
    resourceItems.forEach(item => {
      item.addEventListener("mouseover", (e) => {
        const resourceName = item.innerText.split(":")[0].trim().toLowerCase();
        const prodPerSec = getResourceProductionPerSecond(resourceName);
        resourceTooltip.innerHTML = "Gain: " + prodPerSec.toFixed(2) + " per sec";
        resourceTooltip.style.display = "block";
        resourceTooltip.style.left = e.pageX + 10 + "px";
        resourceTooltip.style.top = e.pageY + 10 + "px";
      });
      item.addEventListener("mousemove", (e) => {
        resourceTooltip.style.left = e.pageX + 10 + "px";
        resourceTooltip.style.top = e.pageY + 10 + "px";
      });
      item.addEventListener("mouseout", () => {
        resourceTooltip.style.display = "none";
      });
    });
    
    /**********************
     * FOOD & WATER CONSUMPTION UPDATE (Every 10 sec)
     **********************/
    /**********************
 * FOOD & WATER CONSUMPTION UPDATE (Every 10 sec)
 **********************/
setInterval(() => {
  // Check if any Well has waterForFood enabled.
  let waterForFoodActive = false;
  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      const building = grid[r][c];
      if (building && building.type === "well" && building.waterForFood === true) {
        waterForFoodActive = true;
        break;
      }
    }
    if (waterForFoodActive) break;
  }
  
  // Determine consumption values based on mode.
  let foodConsumption = 0;
  let waterConsumption = 0;
  if (waterForFoodActive) {
    // When enabled, both food and water consumption are reduced to population/4.
    foodConsumption = resources.population / 4;
    waterConsumption = resources.population / 4;
  } else {
    // Otherwise, food consumption is population/2.
    foodConsumption = resources.population / 2;
    waterConsumption = 0;
  }
  
  // Update the consumption display.
  let displayText = "";
  if (waterForFoodActive) {
    displayText = "Food Consumption: " + foodConsumption.toFixed(2) + " per 10 sec, " +
                  "Water Consumption: " + waterConsumption.toFixed(2) + " per 10 sec";
  } else {
    displayText = "Food Consumption: " + foodConsumption.toFixed(2) + " per 10 sec";
  }
  document.getElementById("foodConsumptionDisplay").innerText = displayText;
  
  // Apply consumption.
  if (resources.population > 0) {
    if (waterForFoodActive) {
      if (resources.food < foodConsumption) {
        resources.population = Math.floor(resources.population / 2);
        addPopup("population", -Math.floor(resources.population));
        resources.food = 0;
      } else {
        resources.food -= foodConsumption;
        addPopup("food", -foodConsumption);
        if (resources.water >= waterConsumption) {
          resources.water -= waterConsumption;
          addPopup("water", -waterConsumption);
        } else {
          resources.water = 0;
        }
      }
    } else {
      if (resources.food < foodConsumption) {
        resources.population = Math.floor(resources.population / 2);
        addPopup("population", -Math.floor(resources.population));
        resources.food = 0;
      } else {
        resources.food -= foodConsumption;
        addPopup("food", -foodConsumption);
      }
    }
    updateResourceDisplay();
  }
}, 10000);

    
    /**********************
     * CONSTRUCTION TIMER / PATCH TIMER
     **********************/
    function updateConstructionTimer() {
      let timerText = "No construction";
      outer: for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          const building = grid[r][c];
          if (building && building.underConstruction) {
            const timeLeft = Math.max(0, Math.ceil((building.constructionComplete - Date.now()) / 1000));
            timerText = building.type + " (" + timeLeft + " sec)";
            break outer;
          }
        }
      }
      document.getElementById("patchTimer").innerText = timerText;
    }
    setInterval(updateConstructionTimer, 200);
    
    /**********************
     * GAME PRODUCTION LOOP (Real-Time Production)
     **********************/
    setInterval(() => {
      const now = Date.now();
      const resourceAssets = ["gold", "silver", "diamond", "bronze", "iron", "steel", "wood"];
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          const building = grid[r][c];
          if (!building) continue;
          if (building.underConstruction) {
            if (now >= building.constructionComplete) {
              building.underConstruction = false;
              building.active = true;
              building.nextProduction = now + buildingTypes[building.type].interval;
              const popupX = building.col * BLOCK_SIZE + 5;
              const popupY = building.row * BLOCK_SIZE + 5;
              spawnFloatingText(popupX, popupY, "Constructed!", "cyan");
            } else {
              continue;
            }
          }
          if (building.active && now >= building.nextProduction) {
            const bt = buildingTypes[building.type];
            let productionAmount = bt.produce * Math.pow(2, building.level - 1);
            if (resourceAssets.includes(building.type)) {
              let obstacleMultiplier = 1;
              if (building.type === "wood") {
                if (isAdjacentToObstacle(building.row, building.col, "tree")) {
                  obstacleMultiplier *= 2;
                }
              } else if (["gold", "silver", "diamond", "bronze", "iron", "steel"].includes(building.type)) {
                if (isAdjacentToObstacle(building.row, building.col, "mountain")) {
                  obstacleMultiplier *= 2;
                }
              }
              productionAmount *= obstacleMultiplier;
              if (building.level >= 2) {
                let utilRequired = 2 * (100 / 1000);
                if (resources.utility < utilRequired) {
                  building.active = false;
                  continue;
                } else {
                  resources.utility -= utilRequired;
                }
              }
              let multiplier = 1;
              if (building.HeroAgentAssigned) multiplier *= 10;
              if (building.syntheticAgentAssigned) multiplier *= 2;
              productionAmount *= multiplier;
              const costFood = (bt.cost.food || 0) * building.level;
              if (resources.food >= costFood && resources.food > 0) {
                resources[bt.resource] += productionAmount;
                addPopup(bt.resource, productionAmount, r, c);
                resources.food -= costFood;
                addPopup("food", -costFood, r, c);
              }
            } else if (["food", "utility", "quarry", "well"].includes(building.type)) {
              if (building.type === "food" || building.type === "well") {
                if (isAdjacentToObstacle(building.row, building.col, "river")) {
                  productionAmount *= 2;
                }
              } else if (building.type === "quarry") {
                if (isAdjacentToObstacle(building.row, building.col, "mountain")) {
                  productionAmount *= 2;
                }
              }
              resources[bt.resource] += productionAmount;
              addPopup(bt.resource, productionAmount, r, c);
            } else if (building.type === "housing") {
              resources[bt.resource] += productionAmount;
              addPopup("population", productionAmount, r, c);
            }
            building.nextProduction += bt.interval;
          }
        }
      }
      updateResourceDisplay();
      drawGrid();
    }, 100);
    
    /**********************
     * POPULATION STARVATION PENALTY
     **********************/
    setInterval(() => {
      if (resources.population > 0) {
        if (resources.food < resources.population) {
          resources.population = Math.floor(resources.population / 2);
          addPopup("population", -Math.floor(resources.population));
          resources.food = 0;
          updateResourceDisplay();
        } else {
          resources.food = Math.max(0, resources.food - resources.population);
          addPopup("food", -resources.population);
          updateResourceDisplay();
        }
      }
    }, 10000);
    
    setInterval(saveGame, 5000);
  </script>
  <script>
    // Example of a custom visual alert function
    function showPopupAlert(message) {
      const overlay = document.createElement("div");
      overlay.style.position = "fixed";
      overlay.style.top = "0";
      overlay.style.left = "0";
      overlay.style.width = "100%";
      overlay.style.height = "100%";
      overlay.style.backgroundColor = "rgba(0,0,0,0.5)";
      overlay.style.display = "flex";
      overlay.style.alignItems = "center";
      overlay.style.justifyContent = "center";
      overlay.style.zIndex = "1000";
      
      const alertBox = document.createElement("div");
      alertBox.style.backgroundColor = "#222";
      alertBox.style.border = "2px solid #FFD700";
      alertBox.style.padding = "20px";
      alertBox.style.color = "#FFD700";
      alertBox.style.fontFamily = "'Press Start 2P', monospace";
      alertBox.style.fontSize = "14px";
      alertBox.style.textAlign = "center";
      alertBox.innerText = message;
      
      const closeBtn = document.createElement("button");
      closeBtn.innerText = "OK";
      closeBtn.style.marginTop = "10px";
      closeBtn.style.padding = "5px 10px";
      closeBtn.style.backgroundColor = "#FFD700";
      closeBtn.style.border = "none";
      closeBtn.style.cursor = "pointer";
      closeBtn.style.borderRadius = "4px";
      closeBtn.addEventListener("click", () => {
        overlay.remove();
      });
      alertBox.appendChild(closeBtn);
      
      overlay.appendChild(alertBox);
      document.body.appendChild(overlay);
    }
  </script>
    <script>
    // Function to display a visual alert when starting construction
    function showConstructionAlert(buildingName) {
      // Create the alert container element
      const alertOverlay = document.createElement("div");
      alertOverlay.style.position = "fixed";
      alertOverlay.style.top = "50%";
      alertOverlay.style.left = "50%";
      alertOverlay.style.transform = "translate(-50%, -50%)";
      alertOverlay.style.padding = "20px 30px";
      alertOverlay.style.backgroundColor = "rgba(34, 34, 34, 0.9)";
      alertOverlay.style.border = "3px solid #FFD700";
      alertOverlay.style.color = "#FFD700";
      alertOverlay.style.fontFamily = "'Press Start 2P', monospace";
      alertOverlay.style.fontSize = "14px";
      alertOverlay.style.textAlign = "center";
      alertOverlay.style.zIndex = "2000";
      alertOverlay.style.borderRadius = "10px";
      alertOverlay.innerText = "Starting construction of " + buildingName + "!";
      
      // Append the alert overlay to the body
      document.body.appendChild(alertOverlay);
      
      // After a delay, fade out and remove the alert overlay
      setTimeout(() => {
        alertOverlay.style.transition = "opacity 1s ease";
        alertOverlay.style.opacity = "0";
        setTimeout(() => {
          alertOverlay.remove();
        }, 1000);
      }, 2000);
    }

    // Wait until the DOM content is fully loaded
    document.addEventListener("DOMContentLoaded", function() {
      // Map building types to their friendly names
      const buildingNames = {
        gold: "Gold Mine",
        silver: "Silver Mine",
        diamond: "Diamond Mine",
        bronze: "Bronze Mine",
        iron: "Iron Mine",
        steel: "Steel Mill",
        wood: "Lumber Mill",
        food: "Food Farm",
        utility: "Utility Center",
        housing: "Housing",
        quarry: "Quarry",
        well: "Well"
      };

      // Add click event listeners to all inventory buttons
      const buildingButtons = document.querySelectorAll('.inventory-button');
      buildingButtons.forEach(button => {
        button.addEventListener('click', function() {
          // Get the building type from the button's data attribute
          const buildingType = this.getAttribute("data-type");
          // Look up the friendly name (or default to the data-type value)
          const buildingName = buildingNames[buildingType] || buildingType;
          // Display the construction alert
          showConstructionAlert(buildingName);
          // (Additional construction logic, like resource deduction, can be added here)
        });
      });
    });
  </script>

<script src="items.js"></script>
<script src="expedition.js"></script>
<script src="crafting.js"></script>
<script>
  // Now you can call Expedition() from your game code.
  const lootItems = Expedition();
  console.log("Expedition Loot:", lootItems);
</script>

</body>
</html>
